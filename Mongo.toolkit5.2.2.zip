{
    "discoveryDefinition": {
        "sourceConfigNameField": "prettyName", 
        "repositoryIdentityFields": [
            "mongoInstallPath", 
            "mongoShellPath"
        ], 
        "repositorySchema": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "version": {
                    "prettyName": "Version", 
                    "type": "string", 
                    "description": "MongoDB Version"
                }, 
                "mongoInstallPath": {
                    "prettyName": "Mongo Install Path", 
                    "type": "string", 
                    "description": "Path to Mongo binaries"
                }, 
                "mongoShellPath": {
                    "prettyName": "Mongo Shell Path", 
                    "type": "string", 
                    "description": "Path to Mongo Shell"
                }, 
                "prettyName": {
                    "prettyName": "Pretty Name", 
                    "type": "string", 
                    "description": "Pretty name of this repository"
                }
            }
        }, 
        "sourceConfigDiscovery": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_TOOLKIT_WORKFLOW=\"sourceConfigDiscovery\",\n   MONGO_VERSION = repository.version,\n   MONGO_INSTALL_PATH = repository.mongoInstallPath,\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nreturn RunBash {\n  command = resources[\"sourceConfigDiscovery.sh\"],\n  environment = remote.environment,\n  user = remote.environmentUser,\n  host = remote.host,\n  variables = env,\n  outputSchema = {\n    type = \"array\",\n    items = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n        prettyName = { type=\"string\" },\n        dbPath = { type=\"string\" },\n        mongoPort = { type=\"integer\" },\n        replicaSet = { type=\"string\" },\n        keyfilePath = { type=\"string\" }\n\n      }\n    }\n  }\n}", 
        "repositoryNameField": "prettyName", 
        "repositoryDiscovery": "--\n-- Copyright (c) 2015 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_TOOLKIT_WORKFLOW=\"repositoryDiscovery\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nreturn RunBash {\n  command = resources[\"repoDiscovery.sh\"],\n  environment = remote.environment,\n  user = remote.environmentUser,\n  host = remote.host,\n  variables = env,\n  outputSchema = {\n    type = \"array\",\n    items = {\n      type=\"object\",\n      additionalProperties = false,\n      properties = {\n        mongoInstallPath  = { type=\"string\" },\n        mongoShellPath  = { type=\"string\" },\n        version      = { type=\"string\" },\n        prettyName   = { type=\"string\" }\n      }\n    }\n  }\n}\n", 
        "sourceConfigSchema": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "mongoPort": {
                    "prettyName": "Mongo Port", 
                    "type": "integer", 
                    "description": "Mongo Port"
                }, 
                "prettyName": {
                    "prettyName": "Pretty Name", 
                    "type": "string", 
                    "description": "Pretty name of this source config"
                }, 
                "dbPath": {
                    "prettyName": "DB Data Path", 
                    "type": "string", 
                    "description": "Path to Mongo Data"
                }, 
                "replicaSet": {
                    "prettyName": "Replica Set Name", 
                    "type": "string", 
                    "description": "Replica Set in use by source"
                }, 
                "keyfilePath": {
                    "prettyName": "Key File Path", 
                    "type": "string", 
                    "description": "Location of the Keyhole"
                }
            }
        }, 
        "type": "ToolkitDiscoveryDefinition", 
        "sourceConfigIdentityFields": [
            "dbPath"
        ]
    }, 
    "snapshotSchema": {
        "additionalProperties": false, 
        "type": "object", 
        "properties": {
            "mongoAuth": {
                "type": "string"
            }, 
            "replicaSet": {
                "type": "string"
            }, 
            "storageEngine": {
                "type": "string"
            }, 
            "toolkitVersion": {
                "type": "string"
            }, 
            "timestamp": {
                "type": "string"
            }, 
            "journalInterval": {
                "type": "integer"
            }, 
            "mongoPort": {
                "type": "integer"
            }, 
            "osType": {
                "type": "string"
            }, 
            "oplogSize": {
                "type": "integer"
            }, 
            "architecture": {
                "type": "string"
            }, 
            "delphixMount": {
                "type": "string"
            }, 
            "mongoVersion": {
                "type": "string"
            }, 
            "osVersion": {
                "type": "string"
            }
        }
    }, 
    "name": "mongo", 
    "linkedSourceDefinition": {
        "status": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n-- staged/status.lua\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_STATUS_TYPE=\"staging\",\n   DLPX_TOOLKIT_WORKFLOW=\"status\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nreturn RunBash {\n  command      = resources['status.sh'],\n  environment  = source.stagingEnvironment,\n  user         = source.stagingEnvironmentUser,\n  host         = source.stagingHost,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n", 
        "parameters": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "mongoUserName": {
                    "default": "clusteradmin", 
                    "environmentVariable": "MONGO_USER_NAME", 
                    "prettyName": "MongoDB User", 
                    "type": "string", 
                    "description": "User must have clusterAdmin role"
                }, 
                "standbyHost": {
                    "default": "linuxsource", 
                    "environmentVariable": "MONGO_STANDBY_HOST", 
                    "prettyName": "Staging Host", 
                    "type": "string", 
                    "description": "Hostname of the new staging Mongo instance"
                }, 
                "journalInterval": {
                    "default": 30, 
                    "environmentVariable": "MONGO_JOURNAL_FLUSH", 
                    "prettyName": "Journal Commit Interval (ms)", 
                    "type": "integer", 
                    "description": "How frequently should the journal data be flushed to disk"
                }, 
                "mongoPort": {
                    "default": 27017, 
                    "environmentVariable": "MONGO_PORT", 
                    "prettyName": "Port Number", 
                    "type": "integer", 
                    "description": "Port number to use for the Mongo staging instance "
                }, 
                "replicaSet": {
                    "default": "delphix", 
                    "environmentVariable": "MONGO_REPLICASET", 
                    "prettyName": "Replicaset", 
                    "type": "string", 
                    "description": "Name of the replica set to connect to"
                }, 
                "oplogSize": {
                    "default": 1024, 
                    "environmentVariable": "MONGO_OPLOG_SIZE", 
                    "prettyName": "Oplog Size (MB)", 
                    "type": "integer", 
                    "description": "Size of the MongoDB oplog in MB"
                }, 
                "keyfilePath": {
                    "default": "/data/mongodb/mongodb.keyfile", 
                    "environmentVariable": "MONGO_KEYFILE_PATH", 
                    "prettyName": "MongoDB Keyfile path", 
                    "type": "string", 
                    "description": "Path to MongoDB keyfile on standby machine. Must have 600 permission for the provisioning user."
                }, 
                "storageEngine": {
                    "description": "Select Storage engine to use", 
                    "default": "wiredTiger", 
                    "enum": [
                        "mmapv1", 
                        "wiredTiger"
                    ], 
                    "environmentVariable": "MONGO_STORAGE_ENGINE", 
                    "prettyName": "Storage Engine", 
                    "type": "string"
                }, 
                "bindIP": {
                    "default": "", 
                    "environmentVariable": "MONGO_BIND_IP", 
                    "prettyName": "bindIP String", 
                    "type": "string", 
                    "description": "CSV string of allowed IPs"
                }, 
                "mongoPassword": {
                    "description": "Password for MongoDB User", 
                    "format": "password", 
                    "default": "delphix", 
                    "environmentVariable": "MONGO_USER_PASSWORD", 
                    "prettyName": "MongoDB Password", 
                    "type": "string"
                }
            }
        }, 
        "stopStaging": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"stopStaging\",\n   VDB_GUID=source.guid,\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\n\ndelphixOwned = RunBash{\n   command     = resources[\"checkOwnership.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = { type = 'boolean' }\n}\n\nif delphixOwned then\n\nRunBash{\n   command     = resources[\"shutdown.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env\n}\n\nRunBash{\n   command     = resources[\"dropStagingFromPrimary.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\nend", 
        "startStaging": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"startStaging\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nRunBash{\n   command     = resources[\"addStagingToPrimary.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\nRunBash{\n   command     = resources[\"startStaging.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env\n}", 
        "resync": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"resync\",\n   VDB_GUID=source.guid,\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\n--\n-- Place a stub in the data directory so we can later verify whether Delphix created this instance\n--\n\nRunBash{\n   command     = resources[\"addStagingToPrimary.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\nRunBash{\n   command     = resources[\"startStaging.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env\n}", 
        "preSnapshot": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"preSnapshot\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nRunBash{\n   command     = resources[\"dropStagingFromPrimary.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\nRunBash{\n   command     = resources[\"saveKeyFile.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env\n}", 
        "type": "ToolkitLinkedStagedSource", 
        "postSnapshot": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_STANDBY_HOST=parameters.standbyHost,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_KEYFILE_PATH=config.keyfilePath,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"postSnapshot\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nRunBash{\n   command     = resources[\"addStagingToPrimary.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\nreturn RunBash {\n  command     = resources[\"recordStatus.sh\"],\n  environment = source.stagingEnvironment,\n  user        = source.stagingEnvironmentUser,\n  host        = source.stagingHost,\n  variables   = env,\n  outputSchema = {\n    type = \"object\",\n    additionalProperties = false,\n    properties = {\n      toolkitVersion = { type=\"string\" },\n      timestamp      = { type=\"string\" },\n      architecture   = { type=\"string\" },\n      osType         = { type=\"string\" },\n      osVersion      = { type=\"string\" },\n      mongoVersion   = { type=\"string\" },\n      delphixMount   = { type=\"string\" },\n      mongoPort      = { type=\"integer\" },\n      storageEngine  = { type=\"string\" },\n      mongoAuth      = { type=\"string\" },\n      replicaSet     = { type=\"string\" },\n      journalInterval = { type=\"integer\" },\n      oplogSize      = { type=\"integer\" }\n   }\n  }\n}"
    }, 
    "buildApi": {
        "micro": 0, 
        "major": 1, 
        "type": "APIVersion", 
        "minor": 9
    }, 
    "virtualSourceDefinition": {
        "status": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n-- virtual/status.lua\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_STATUS_TYPE=\"virtual\",\n   DLPX_TOOLKIT_WORKFLOW=\"status\"\n}\n\nreturn RunBash {\n  command      = resources['status.sh'],\n  environment  = source.environment,\n  user         = source.environmentUser,\n  host         = source.host,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n", 
        "configure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\n-- snapshotJson passed to configure and reconfigure\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"configure\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nprovisionInfo = RunBash{\n   command     = resources[\"provision.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         dbPath = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         prettyName = { type=\"string\" }\n      }\n  }\n}\n\nRunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\n-- RunBash{\n--   command     = resources[\"initiate.sh\"],\n--   environment = source.environment,\n--   user        = source.environmentUser,\n--   host        = source.host,\n--   variables   = env\n-- }\n\nreturn provisionInfo", 
        "parameters": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "mongoUserName": {
                    "default": "clusteradmin", 
                    "environmentVariable": "MONGO_USER_NAME", 
                    "prettyName": "MongoDB User", 
                    "type": "string", 
                    "description": "User must have dbAdmin and clusterAdmin roles"
                }, 
                "journalInterval": {
                    "default": 30, 
                    "environmentVariable": "MONGO_JOURNAL_FLUSH", 
                    "prettyName": "Journal Commit Interval (ms)", 
                    "type": "integer", 
                    "description": "How frequently should the journal data be flushed to disk"
                }, 
                "mongoPort": {
                    "default": 27018, 
                    "environmentVariable": "MONGO_PORT", 
                    "prettyName": "Port Number", 
                    "type": "integer", 
                    "description": "MongoDB"
                }, 
                "oplogSize": {
                    "default": 1024, 
                    "environmentVariable": "MONGO_OPLOG_SIZE", 
                    "prettyName": "Oplog Size (MB)", 
                    "type": "integer", 
                    "description": "Size of the MongoDB oplog in MB"
                }, 
                "bindIP": {
                    "default": "", 
                    "environmentVariable": "MONGO_BIND_IP", 
                    "prettyName": "bindIP String", 
                    "type": "string", 
                    "description": "CSV string of allowed IPs"
                }, 
                "mongoPassword": {
                    "description": "Password for MongoDB User", 
                    "format": "password", 
                    "default": "delphix", 
                    "environmentVariable": "MONGO_USER_PASSWORD", 
                    "prettyName": "MongoDB Password", 
                    "type": "string"
                }
            }
        }, 
        "stop": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   DLPX_TOOLKIT_WORKFLOW=\"stop\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\ndelphixOwned = RunBash{\n   command     = resources[\"checkOwnership.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = 'boolean' }\n}\n\nif delphixOwned then\n\n\tRunBash{\n   \t\tcommand     = resources[\"shutdown.sh\"],\n   \t\tenvironment = source.environment,\n   \t\tuser        = source.environmentUser,\n   \t\thost        = source.host,\n   \t\tvariables   = env\n\t}\n\nend", 
        "start": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"start\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nRunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}", 
        "unconfigure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   DLPX_TOOLKIT_WORKFLOW=\"unconfigure\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\ndelphixOwned = RunBash{\n   command     = resources[\"checkOwnership.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = 'boolean' }\n}\n\nif delphixOwned then\n\n\tRunBash{\n   \t\tcommand     = resources[\"shutdown.sh\"],\n   \t\tenvironment = source.environment,\n   \t\tuser        = source.environmentUser,\n   \t\thost        = source.host,\n   \t\tvariables   = env\n\t}\nend", 
        "reconfigure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\n-- snapshotJson passed to configure and reconfigure\nenv = {\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"reconfigure\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nprovisionInfo = RunBash{\n   command     = resources[\"provision.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         dbPath = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         prettyName = { type=\"string\" }\n      }\n  }\n}\n\nRunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\n-- RunBash{\n--   command     = resources[\"initiate.sh\"],\n--   environment = source.environment,\n--   user        = source.environmentUser,\n--   host        = source.host,\n--   variables   = env\n-- }\n\nreturn provisionInfo", 
        "preSnapshot": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_STAGING_SERVER_BOOL=false,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"preSnapshot\"\n}", 
        "type": "ToolkitVirtualSource", 
        "postSnapshot": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   MONGO_USER_NAME=parameters.mongoUserName,\n   MONGO_USER_PASSWORD=parameters.mongoPassword,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_STAGING_SERVER_BOOL=false,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   DLPX_TOOLKIT_WORKFLOW=\"postSnapshot\",\n   MONGO_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nreturn RunBash{\n   command     = resources[\"recordStatus.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         toolkitVersion = { type=\"string\" },\n         timestamp = { type=\"string\" },\n         architecture = { type=\"string\" },\n         osType = { type=\"string\" },\n         osVersion = { type=\"string\" },\n         mongoVersion = { type=\"string\" },\n         delphixMount = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         storageEngine = { type=\"string\" },\n         mongoAuth = { type=\"string\" },\n         replicaSet = { type=\"string\" },\n         journalInterval = { type=\"integer\" },\n         oplogSize = { type=\"integer\" }\n      }\n   }\n}"
    }, 
    "hostTypes": [
        "UNIX"
    ], 
    "version": "0.9.1", 
    "defaultLocale": "en-us", 
    "prettyName": "MongoDB", 
    "type": "Toolkit", 
    "resources": {
        "provision.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# provision.sh\nset -xv\nset -o functrace\n# Include Library functions from mount parent\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='provision.sh'\n\nlog \"Starting $PGM_NAME\"\n\n\ninitializeJQ\n\ngetSystemInfo\n\nif [[ -z \"$MONGO_SNAPSHOT_METADATA\" ]]; then\n        log -d \"Mongo Provisioning Error: Empty snapshot metadata ($MONGO_SNAPSHOT_METADATA)\"\n        exit 2\nfi\n\nlog \"MONGO_SNAPSHOT_METADATA=$MONGO_SNAPSHOT_METADATA\"\n\nsnapshotVersion=MONGO_SNAPSHOT_METADATA\nconfirmSnapshotValue \"toolkitVersion\" \"$TOOLKIT_VERSION\"\nconfirmSnapshotValue \"architecture\" \"$ARCH\"\nconfirmSnapshotValue \"osType\" \"$OSTYPE\"\nconfirmSnapshotValue \"osVersion\" \"$OSVERSION\"\nconfirmSnapshotValue \"mongoVersion\" \"$MONGO_VERSION\"\n\n# Check if there is an existing instance on Mongo listening on that port number\nlog \"Checking for existing Mongo instance at $MONGO_PORT\"\nexisting_instances=$(sudo /usr/sbin/lsof -iTCP | grep \"LISTEN\")\nerrorCheck \"Unable to check for existing Mongo Instances\\n$existing_instances\"\n# TODO: need a better check for grep errors\nexisting_instances=$(echo \"$existing_instances\" | grep mongo)\nif [[ $? -eq 0 ]]; then\n        # TODO: need a better check for grep errors\n        existing_instances=$(echo \"$existing_instances\" | grep $MONGO_PORT | wc -l)\n        errorCheck \"Unable to check for existing Mongo Instances\\n$existing_instances\"\n        if [[ $existing_instances -ne 0 ]]; then\n                xyz=$(ps -ef )\n                die \"Existing Mongo instance listening on port $MONGO_PORT. Listing processes:\\n${xyz})\"\n        fi\nfi\n\ngetSnapshotValue \"storageEngine\" \"MONGO_STORAGE_ENGINE\"\ngetSnapshotValue \"mongoAuth\" \"MONGO_AUTH\"\n#getSnapshotValue \"replicaSet\" \"MONGO_REPLICASET\"\n\noutput_string=$(printf \"MONGO_STORAGE_ENGINE: $MONGO_STORAGE_ENGINE\")\noutput_string=$(printf \"${output_string}\\nMONGO_AUTH: $MONGO_AUTH\")\n#output_string=$(printf \"${output_string}\\nMONGO_REPLICASET: $MONGO_REPLICASET\")\n# Write the output data to the config file - overwrites existing\necho \"$output_string\" >${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nprettyName=\"Mongo:$MONGO_PORT - ${DLPX_DATA_DIRECTORY}\"\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoPort = $MONGO_PORT\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$outputJSON\")\nlog \"writing outputJSON to DLPX_OUTPUT_FILE: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\ncompleted_code=1\n#while [[ completed_code -ne 0 ]]\n#do\n#        sleep 10\n#        checkReplicationStatus\n#        completed_code=$?\n#done\n\nexit 0", 
        "initializeVDB.sh": "#\n# Copyright (c) 2017 by Delphix. All rights reserved.\n#\n\n# We keep track of whether a VDB is running or not using a sentinel files.\n# Each running VDB has its own sentinel file, named using the VDB's GUID.\n# All of the sentinel files for a particular host are kept in a single directory,\n# inside the Delphix Engine's \"toolkit directory\".\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='initializeVDB.sh'\n\nlog \"Starting $PGM_NAME\"\n\nSTATUS_DIR=${DLPX_DATA_DIRECTORY}\nSTATUS_FILE=${STATUS_DIR}/status-${VDB_GUID}\n\n# Making sure the sentinel file exists.\ntouch ${STATUS_FILE}\n", 
        "library.sh": "#\n# Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n#\n# library.sh\n#\n# library of common functions used in the toolkit\n#\nset -xv\n# Globals\nTOOLKIT_VERSION=\"0.9.1\"\nTIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\nCONFIG_OUTPUT_FILE=\"delphixMongoConfig.dat\"\nMONGO_ERROR_LOG=\"delphixMongoError.log\"\nMONGO_DEBUG_LOG=\"delphixMongoDebug.log\"\n\n# Log infomation and die if option -d is used.\nfunction log {\n        Parms=$@\n        die='no'\n        if [[ $1 = '-d' ]]; then\n                shift\n                die='yes'\n                Parms=$@\n        fi\n        printf \"${TIMESTAMP} %15s - %s: $Parms\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME\n        printf \"${TIMESTAMP} %15s - %s: $Parms\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME >> /tmp/$MONGO_DEBUG_LOG\n        if [[ $die = 'yes' ]]; then\n                exit 2\n        fi\n}\n\n# Log error and write to the errorlog\nfunction errorLog {\n        log \"$@\"\n        printf \"${TIMESTAMP} %15s - %s: $@\\n\" $DLPX_TOOLKIT_WORKFLOW >> /tmp/$MONGO_ERROR_LOG\n}\n\n# Write to log and errorlog before exiting with an error code\nfunction die {\n        errorLog \"$@\"\n        exit 2\n}\n\n# Function to check for errors and die with passed in error message\nfunction errorCheck {\n        if [ $? -ne 0 ]; then\n                die \"$@\"\n        fi\n}\n\n# Function that returns 0 if the replica is in a healthy state\nfunction checkReplicationStatus {\n\n\tlog \"checkReplicationStatus Checking Status\"\n        # Get replicaset status\n        json=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\nlog \"json: $json\"\n        # Get hostname - need this to lookup the member status\n        hostname=$(hostname)\n        # We are intentionally supressing errors at .[] so that JQ does not throw an additional error when rs.status fails\n        mongo_state=$(echo \"$json\" | jq \".members | .[]? | select(.self == true) | .state\")\n        errorLog \"checkReplicationStatus warning: Unable to check Mongo status\"\n        if [[ mongo_state -ne 2 ]]; then\n                errorLog \"checkReplicationStatus warning: Mongo in invalid state ($mongo_state)\"\n                return 1\n        fi\n        log \"checkReplicationStatus: Replication status is good\"\n        return 0\n}\n\n#\n# Function to collect system info\n# ARCH, OSTYPE, OSVERSION, MONGO_VERSION\n#\nfunction getSystemInfo {\n\tlog \"getSystemInfo: Getting system info\"\n        ARCH=$(uname -p)\n        OSTYPE=$(uname)\n        if [ \"$OSTYPE\" = \"SunOS\" ]; then\n                OSTYPE=\"Solaris\"\n                OSVERSION=$(uname -v)\n                OSSTR=\"$OSTYPE ${REV}(${ARCH} `uname -v`)\"\n        elif [ \"$OSTYPE\" = \"AIX\" ]; then\n                OSSTR=\"$OSTYPE `oslevel` (`oslevel -r`)\"\n                OSVERSION=$(oslevel)\n        elif [ \"$OSTYPE\" = \"Linux\" ]; then\n                if [ -f /etc/redhat-release ]; then\n                        OSTYPE=RedHat\n                        OSVERSION=$(cat /etc/redhat-release | sed 's/.*release\\ //' | sed 's/\\ .*//')\n                else\n                        die \"Unsupported Linux Distro\"\n                fi\n        fi\n        # Get Mongo version\n        MONGO_VERSION=$(mongod --version | grep \"db version\" | awk '{print $3}')\n        MONGO_STORAGE_ENGINE=\n}\n\n#\n# Search for the value of the search_term in the delphixMongoConfig.dat file\n# If value is found it is stored in the response_variable_name variable, if not\n# the function dies with error\n# Input params: config term (eg: TOOLKIT_VERSION, DB2VERSION, etc...) and\n# response_variable_name\n#\nfunction getConfigValue {\n\tlog \"getConfigValue: Getting Config Value --> $search_term\"\n        if [ \"$#\" -ne 2 ]; then\n                die \"Mongo Config Error: Incorrect params to getConfigValue($@). Expecting search_term and response_variable_name\"\n        fi\n        local search_term=\"$1\"\n        local response_variable_name=\"$2\"\n        if [ -z \"$search_term\" ]; then\n                die \"Mongo Config Error: Empty search param for getConfigValue()\"\n        fi\n        if [ -z \"$response_variable_name\" ]; then\n                die \"Mongo Config Error: Empty response variable param for getConfigValue()\"\n        fi\n        local response_value=$(grep -F \"$search_term\" $DLPX_DATA_DIRECTORY/$CONFIG_OUTPUT_FILE | awk 'NF>1{print $NF}')\n        errorCheck \"Mongo Config Error: Unable to find config value for $search_term\"\n        if [ -z \"$response_value\" ]; then\n                die \"Mongo Config Error: Unable to find config value for $search_term\"\n        fi\n        # Set the named response variable to the appropriate value\n        eval $response_variable_name=\\$response_value\n}\n\n#\n# Confirm that the value of the config param on the current host matches the\n# snapshot\n# Input params: config term and current value\n#\nfunction confirmConfigValue {\n\tlog \"confirmConfigValue: Confirming Config Value --> Search:$1 Current:$2\"\n        if [ \"$#\" -ne 2 ]; then\n                die \"Mongo Config Error: Incorrect params to confirmConfigValue($@)\"\n        fi\n        local search_term=\"$1\"\n        local current_value=\"$2\"\n        if [ -z \"$search_term\" ]; then\n                die \"Mongo Config Error: Empty search_term for confirmConfigValue()\"\n        fi\n        if [ -z \"$current_value\" ]; then\n                die \"Mongo Config Error: Empty current_value for confirmConfigValue()\"\n        fi\n        # Store the snapshot value of the config in a temp variable\n        getConfigValue \"$search_term\" \"temp_variable\"\n        # Compare current value of the term against the temp_variable\n        if [ \"$current_value\" != \"$temp_variable\" ]; then\n                die \"Mongo Config Error: $search_term of snapshot ($temp_variable) does not match this server ($current_value)\"\n        fi\n}\n\n#\n# Search for the value of the search_term in the snapshotJson metadata\n# If value is found it is stored in the response_variable_name variable, if not\n# the function dies with error\n# Input params: config term (eg: toolkitVersion, MongoVersion, etc...) and\n# response_variable_name\n#\nfunction getSnapshotValue {\n\tlog \"getSnapshotValue: Getting Snapshot Value --> Search:$1 Response:$2\"\n        if [[ \"$#\" -ne 2 ]]; then\n                log -d \"Mongo Config Error: Incorrect params to getConfigValue($@). Expecting search_term and response_variable_name\"\n        fi\n        local search_term=\"$1\"\n        local response_variable_name=\"$2\"\n        if [[ -z \"$search_term\" ]]; then\n                log -d \"Mongo Config Error: Empty search param for getConfigValue()\"\n        fi\n        if [[ -z \"$response_variable_name\" ]]; then\n                log -d \"Mongo Config Error: Empty response variable param for getConfigValue()\"\n        fi\n        local response_value\n        #using the -r option to get unquoted raw output strings\n        response_value=$($DLPX_BIN_JQ -r \".${search_term}\" <<< \"$MONGO_SNAPSHOT_METADATA\")\n        errorCheck \"Mongo Config Error: Unable to find config value for $search_term (E1)\\n$response_value\"\n        if [[ \"$response_value\" = \"null\" ]]; then\n                log -d \"Mongo Config Error: Unable to find config value for $search_term (E2)\\n$response_value\"\n        fi\n        if [[ -z \"$response_value\" ]]; then\n                log -d \"Mongo Config Error: Unable to find config value for $search_term (E3)\\n$response_value\"\n        fi\n        # Set the named response variable to the appropriate value\n        eval $response_variable_name=\\$response_value\n}\n\n#\n# Confirm that the value of the config param on the current host matches the\n# snapshotJson metadata\n# Input params: config term and current value\n#\nfunction confirmSnapshotValue {\n\n\tlog \"confirmSnapshotValue: Confirming Snapshot Value --> Search:$1 Current:$2\"\n\n        if [[ \"$#\" -ne 2 ]]; then\n                log -d \"Mongo Config Error: Incorrect params to confirmConfigValue($@)\"\n        fi\n        local search_term=\"$1\"\n        local current_value=\"$2\"\n\n        if [[ -z \"$search_term\" ]]; then\n                log -d \"Mongo Config Error: Empty search_term for confirmConfigValue()\"\n        fi\n        if [[ -z \"$current_value\" ]]; then\n                log -d \"Mongo Config Error: Empty current_value for confirmConfigValue()\"\n        fi\n\n        # Store the snapshot value of the config in a temp variable\n        getSnapshotValue \"$search_term\" \"temp_variable\"\n        # Compare current value of the term against the temp_variable\n        if [[ \"$current_value\" != \"$temp_variable\" ]]; then\n                log -d \"Mongo Config Error: $search_term of snapshot ($temp_variable) does not match this server ($current_value)\"\n        fi\n}\n\n# Function to grab the primary instance port\nfunction getPrimaryReplica() {\n        local inputReplicaSet=$1\n        local currentMongoProcess\n        local currentReplicaSet\n        local currentReplicaPort\n        local primaryReplica\n        local firstHost\n\n# Set the delimiter to new line for the loop\nIFS=$'\\n'\n\n# Grab the first mongod process that belongs to the desired replica set\n\nfor currentMongoProcess in $(ps -ef | grep [m]ongod | awk '{s=\"\";for (i=8;i<=NF;i++) {printf(\"%s \", $i)} ; printf(\"\\n\")}') ; do\n        currentReplicaSet=$(echo \"$currentMongoProcess\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--replSet\") {print $(i+1)}}')\n        if [[ \"$currentReplicaSet\" == \"$inputReplicaSet\" ]]; then\n                break;\n        fi\ndone\n\n# Get the port number from the ps results\n\n        currentReplicaPort=$(echo \"$currentMongoProcess\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--port\") {print $(i+1)}}')\n\n# Grab the connection string for the primary replica host\n        primaryReplica=$(mongo -u clusteradmin -p delphix -port \"$currentReplicaPort\" admin -quiet -eval \"db.isMaster().primary\")\n\n        echo $primaryReplica\n}\n\n\n\n#\n# Confirm that JQ is available on this system and add it to path\n#\n#\nfunction initializeJQ {\n        # Add jq to PATH for convenience. Note that it is appended to the front so we\n        # will always use it even if jq is installed elsewhere on the machine\n        PATH=\"$(dirname \"$DLPX_BIN_JQ\"):${PATH}\"\n\n        # Confirm that invoking jq works properly\n        jq '.' <<< '{}' >/dev/null 2>/dev/null\n        errorCheck 'Unable to initialize JQ'\n}\n\n#\n# Quotes strings for use with JSON. Fails if the number of arguments is not\n# exactly one because it will not do what the user likely expects.\n#\nfunction jqQuote\n{\n        if [[ \"$#\" -ne 1 ]]; then\n                log -d \"Wrong number of arguments to jqQuote: $@\"\n        fi\n        $DLPX_BIN_JQ -R '.' <<< \"$1\"\n}\n\n# Quotes strings for use with JSON. Fails if the number of arguments is not\n# exactly one because it will not do what the user likely expects.\nfunction quote {\n  if [[ \"$#\" -ne 1 ]]; then\n    die \"Wrong number of arguments to quote: $@\"\n  fi\n  jq -R '.' <<< \"$1\"\n}\n\n", 
        "recordStatus.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# recordStatus.sh\nset -xv\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='recordStatus.sh'\n\ngetSystemInfo\n\ninitializeJQ\n\n# Grab the primary replication port and host\nprimaryReplica=$(getPrimaryReplica \"$MONGO_REPLICASET\")\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\n# Lookup the current mongo storage engine\nMONGO_STORAGE_ENGINE=$(mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.serverStatus().storageEngine)\")\nMONGO_STORAGE_ENGINE=$(echo \"$MONGO_STORAGE_ENGINE\" | jq -r '.name')\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n        MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\n\nMONGO_REPLICASET=$(mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.conf())\")\nMONGO_REPLICASET=$(echo \"$MONGO_REPLICASET\" | jq -r '._id')\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n        if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n                MONGO_AUTH='keyfile'\n        fi\nelse\n        instances=$(ps -ef | grep [m]ongod | awk '{ s = \"\"; for (i = 8; i <= NF; i++) s = s $i \" \"; print s }')\n        log \"instances=$instances\"\n        #$IFS (internal field separator) determines how Bash recognizes word boundaries\n        #Temporarily set $IFS to \\n (defaults to whitespace)\n        OLD_IFS=\"$IFS\"\n        IFS=$'\\n'\n        for currentInstance in $instances; do\n                dbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n                port=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | bc)\n                keyfile=$(echo \"$currentInstance\" | grep -Po '(?<=--keyFile\\s)[^\\s]*')\n                replSet=$(echo \"$currentInstance\" | grep -Po '(?<=--replSet\\s)[^\\s]*')\n                if [[ $dbPath = ${DLPX_DATA_DIRECTORY} && $port = $MONGO_PORT ]]; then\n                        if [[ ! -z $keyfile ]]; then\n                                log \"keyfile not empty ($keyfile), set MONGO_AUTH='keyfile'\"\n                                MONGO_AUTH='keyfile'\n                        fi\n                        if [[ -z $MONGO_REPLICASET ]]; then\n                                log \"MONGO_REPLICASET not set, setting to $replSet\"\n                                MONGO_REPLICASET=$replSet\n                        fi\n                fi\n        done\n        IFS=\"$OLD_IFS\"\nfi\n\noutput_string=$(printf \"MONGO_STORAGE_ENGINE: $MONGO_STORAGE_ENGINE\")\noutput_string=$(printf \"${output_string}\\nMONGO_AUTH: $MONGO_AUTH\")\noutput_string=$(printf \"${output_string}\\nMONGO_REPLICASET: $MONGO_REPLICASET\")\nlog \"Writing config info to ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}: $output_string\"\n# Write the output data to the config file - overwrites existing\necho \"$output_string\" >${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".toolkitVersion = $(jqQuote \"$TOOLKIT_VERSION\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".timestamp = $(jqQuote \"$TIMESTAMP\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".architecture = $(jqQuote \"$ARCH\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".osType = $(jqQuote \"$OSTYPE\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".osVersion = $(jqQuote \"$OSVERSION\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoVersion = $(jqQuote \"$MONGO_VERSION\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".delphixMount = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoPort = $MONGO_PORT\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".storageEngine = $(jqQuote \"$MONGO_STORAGE_ENGINE\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoAuth = $(jqQuote \"$MONGO_AUTH\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".replicaSet = $(jqQuote \"$MONGO_REPLICASET\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".journalInterval = $MONGO_JOURNAL_FLUSH\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".oplogSize = $MONGO_OPLOG_SIZE\" <<< \"$outputJSON\")\nif [[ -z $outputJSON ]]; then\n        outputJSON='{}'\nfi\nlog \"writing outputJSON to $DLPX_OUTPUT_FILE --> $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nexit 0", 
        "addStagingToPrimary.sh": "#\nset -x\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# addStagingToPrimary.sh\n\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME=\"addStagingToPrimary.sh\"\n\n# Grab the host we are running this script on\nhostname=$(hostname)\n\nlog \"Executing $PGM_NAME\"\n\ninitializeJQ\n\n# Grab the primary replication port and host\nprimaryReplica=$(getPrimaryReplica \"$MONGO_REPLICASET\")\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\n#For MongodDB  <= 2.8, need to specify an unused _id value in the replica set\nlog \"mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \\\"printjson(JSON.stringify(rs.status()))\"\\\"\njson=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n\n#_id An integer identifier of every member in the replica set. Values must be between 1 and 255 inclusive.\n#see https://docs.mongodb.org/manual/reference/replica-configuration/#rsconf.members[n]._id\nfor i in {0..255}; do\n        member=$(echo \"$json\" | jq \".members | .[] | select(._id == $i)\")\n        if [ -z \"$member\" ]; then\n                new_id=$i\n                break\n        fi\ndone\n\nif [ -z \"$new_id\" ]; then\n        die \"no valid ids available in replica set\"\nfi\n\nlog \"Adding Delphix staging host $MONGO_STANDBY_HOST:${MONGO_PORT} to replica set with _id=$new_id\"\nlog \"mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \\\"printjson(JSON.stringify(rs.add({host:'$MONGO_STANDBY_HOST:${MONGO_PORT}', priority: 0, hidden: true, _id: $new_id})))\\\"\"\noutput=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.add({host:'$MONGO_STANDBY_HOST:${MONGO_PORT}', priority: 0, hidden: true, _id: $new_id}))\")\nsuccess=$(echo \"$output\" | jq '.ok')\n#Code 103 = Found two member configurations with same host field, meaning staging server already added\nif [ $success -eq 0 ]\nthen\n        code=$(echo \"$output\" | jq '.code')\n        errmsg=$(echo \"$output\" | jq '.errmsg')\n        die \"rs.add failed: Code: $code error:  $errmsg\"\nelse\n        log \"rs.add succeeded\"\nfi\n\nexit 0", 
        "repoDiscovery.sh": "#\n# Copyright (c) 2015 by Delphix. All rights reserved.\n#\n# This file repo discovery for Mongo by searching for the mongod and mongo processes in /usr/bin\n#\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='repoDiscovery.sh'\n\nlog \"Executing repoDiscovery.sh\"\n\n#add jq to the path\n\ninitializeJQ\n\n# See if mongo service exist\n\nINSTALLPATH=$(find /usr/bin -name mongod | head -1)\nif [[ \"$INSTALLPATH\" = '' ]]; then\n        # Install path not found - return empty repo config\n        echo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n        exit 0\nfi\n\n# See if mongo shell exist\n\nSHELLPATH=$(find /usr/bin -name mongo | head -1)\nif [[ \"$SHELLPATH\" = '' ]]; then\n        # Shell path not found - return empty repo config\n        echo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n        exit 0\nfi\n\n# Grab the primary replication port and host\nprimaryReplica=$(getPrimaryReplica \"$MONGO_REPLICASET\")\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\n# Query the current Mongo instance for version info\n\nVERSION=$($SHELLPATH --host \"$primaryHost\" --port \"$primaryPort\" --quiet --eval \"db.version()\")\n# If Mongod is not running we use the shell version number as the fallback\nif [[ $? -ne 0 ]]; then\n        VERSION=$(mongo --version | awk '{print $4;}' | head -n 1)\nfi\nerrorCheck \"Found Mongo install ($INSTALLPATH) and shell ($SHELLPATH) but unable to query shell ($VERSION)\"\n\nlog \"DLPX_OUTPUT_FILE: $DLPX_OUTPUT_FILE\"\n\n# Assemble JSON and write output variables to output file\nPRETTYNAME=\"MongoDB (${VERSION})\"\n\nREPOSITORIES='[]'\nCURRENT_REPO='{}'\nCURRENT_REPO=$(jq \".mongoInstallPath = $(quote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\nCURRENT_REPO=$(jq \".mongoShellPath = $(quote \"$SHELLPATH\")\" <<< \"$CURRENT_REPO\")\nCURRENT_REPO=$(jq \".version = $(quote \"$VERSION\")\" <<< \"$CURRENT_REPO\")\nCURRENT_REPO=$(jq \".prettyName = $(quote \"$PRETTYNAME\")\" <<< \"$CURRENT_REPO\")\nREPOSITORIES=$(jq \". + [$CURRENT_REPO]\" <<< \"$REPOSITORIES\")\n\necho \"$REPOSITORIES\" >> \"$DLPX_OUTPUT_FILE\"\nerrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\nlog \"REPOSITORIES: $REPOSITORIES\"\n\nexit 0\n", 
        "shutdown.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# shutdown.sh\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='shutdown.sh'\n\nlog \"GUID: $VDB_GUID\"\nlog \"MONGO_KEYFILE_PATH: $MONGO_KEYFILE_PATH\"\nlog \"MONGO_REPLICASET: $MONGO_REPLICASET\"\n\nlog \"mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \\\"db.getSiblingDB('admin').shutdownServer({force: true})\\\"\"\n\noutput=$(mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"db.getSiblingDB('admin').shutdownServer({force: true})\")\nlog \"Shutting Down Mongo:\\n$output\"\nexit 0\n", 
        "start.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# start.sh\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='start.sh'\n\ngetSystemInfo\n\ngetConfigValue \"MONGO_STORAGE_ENGINE\" \"MONGO_STORAGE_ENGINE\"\ngetConfigValue \"MONGO_AUTH\" \"MONGO_AUTH\"\n#getConfigValue \"MONGO_REPLICASET\" \"MONGO_REPLICASET\"\n\n# Construct base command\nmongoCommand=\"mongod --logpath ${DLPX_DATA_DIRECTORY}/mongod.log --fork --dbpath $DLPX_DATA_DIRECTORY --journal --journalCommitInterval $MONGO_JOURNAL_FLUSH --oplogSize $MONGO_OPLOG_SIZE --port $MONGO_PORT\"\n\n# If storage engine is anything but mmap we need to add it explicitly. This is because --storageEngine is not a valid param for 2.6\nif [[ ! -z $MONGO_STORAGE_ENGINE ]] && [[ \"$MONGO_STORAGE_ENGINE\" != \"mmapv1\" ]]; then\n        mongoCommand=\"$mongoCommand --storageEngine $MONGO_STORAGE_ENGINE\"\nfi\n\n# If there is keyfile auth then enable it from the known keyfile location\nif [[ \"$MONGO_AUTH\" == \"keyfile\" ]]; then\n        mongoCommand=\"$mongoCommand --keyFile ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\nfi\n\nlog \"Starting Mongo VDB:\\n$mongoCommand\"\noutput=$($mongoCommand)\nlog \"Result:\\n$output\"\n\n#sleep 20\n\nexit 0", 
        "sourceConfigDiscovery.sh": "#\n# Copyright (c) 2016 by Delphix. All rights reserved.\n#\n# This file handles sourceConfig discovery for Mongo. It will only scan for running instances of Mongod and will NOT find dormant instances\n#\n\n# Helper function declarations\n\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME=\"sourceConfigDiscover.sh\"\n\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Check to see Mongo Version or install path are empty\nif [[ \"$MONGO_VERSION\" = '' ]] || [[ \"$MONGO_INSTALL_PATH\" = '' ]]; then\n        die 'MONGO_VERSION or MONGO_INSTALL_PATH not set when doing source config discovery'\nfi\n\n# Find the mongo instances\n\ninstances=$(ps -ef | grep [m]ongod | awk '{ s = \"\"; for (i = 8; i <= NF; i++) {printf( \"%s \", $i )}; printf(\"\\n\")}')\nerrorCheck \"Error finding Mongo instances \\n${instances}\"\nlog \"instances: $instances\"\n\n# Get configs for each instance\n\nsourceConfigs='[]'\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\nfor currentInstance in $instances; do\n        dbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n        port=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | bc)\n\treplSet=$(echo \"$currentInstance\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--replSet\") {print $(i+1)}}')\n\tkeyFilePath=$(echo \"$currentInstance\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--keyFile\") {print $(i+1)}}')\n\n        if [[ -z $dbPath ]] || [[ -z $port ]]; then\n                # config files are specified with either -f or --config\n                config=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n                if [[ -z $dbPath ]] && [[ -n $config ]]; then\n                        dbPath=$(cat $config | grep -v '^#' | grep '^dbpath=' | sed -e 's/\\dbpath=//g')\n\t\telse\n                        #if not found set to default value\n                        dbPath=\"/data/db\"\n                fi\n                if [[ -z $port ]] && [[ -z $config ]]; then\n                        port=$(cat $config | grep -v '^#' | grep '^port=' | sed -e 's/\\port=//g')\n\t\telse\n                        #if not found set to default value\n                        port=27017\n                fi\n        fi\n        log \"dbpath:$dbPath port:$port config:$config\"\n\n# Grab data path, port, & pretty name for display on environment screen\n        prettyName=\"Mongo:${port} - $dbPath\"\n        currentSourceConfig='{}'\n        currentSourceConfig=$(jq \".dbPath = $(quote \"$dbPath\")\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$(jq \".mongoPort = $port\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$(jq \".replicaSet = $(quote \"$replSet\")\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$(jq \".keyfilePath = $(quote \"$keyFilePath\")\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$(jq \".prettyName = $(quote \"$prettyName\")\" <<< \"$currentSourceConfig\")\n        sourceConfigs=$(jq \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\ndone\nIFS=\"$OLD_IFS\"\n\nlog \"Source Configs: $sourceConfigs\"\necho \"$sourceConfigs\" > \"$DLPX_OUTPUT_FILE\"\nerrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\nexit 0", 
        "writeLibrary.sh": "#\n# Copyright (c) 2016 by Delphix. All rights reserved.\n#\n# writeLibrary.sh\n#\n# Script to write the contents of $DB2_LIBRARY_SOURCE as the toolkit library\n# file to the DLPX_DATA_DIRECTORY location\n#\n\nPGM_NAME='writeLibrary.sh'\n\nTIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\nMONGO_DEBUG_LOG=\"delphixMongoDebug.log\"\nMONGO_ERROR_LOG=\"delphixMongoError.log\"\n\n# Log function that merely echoes to stdout for now\nfunction log {\n        printf \"${TIMESTAMP} %15s - %s: $@\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME\n        printf \"${TIMESTAMP} %15s - %s: $@\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME >>${DLPX_DATA_DIRECTORY}/../$MONGO_DEBUG_LOG\n}\n\n# Log error and write to the errorlog\nfunction errorLog {\n        echo -e \"$@\"\n        echo -e \"[${TIMESTAMP}] $@\" >>${DLPX_DATA_DIRECTORY}/../$MONGO_ERROR_LOG\n}\n\n# Write to log and errorlog before exiting with an error code\nfunction die {\n        errorLog \"$@\"\n        exit 2\n}\n\n# Function to check for errors and die with passed in error message\nfunction errorCheck {\n        if [ $? -ne 0 ]; then\n                die \"$@\"\n        fi\n}\n\nif [ -z \"$MONGO_LIBRARY_SOURCE\" ]; then\n        die \"Mongo Library Error: Unable to load Mongo Library source \"\nfi\n\necho \"$MONGO_LIBRARY_SOURCE\" >${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\nerrorCheck \"Mongo Library Error: Unable to write Mongo Library to ${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\"\n\nlog \"Wrote library.sh to ${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\"", 
        "saveKeyFile.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# saveKeyFile.sh\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='saveKeyFile.sh'\n\nlog \"Saving Keyfile $MONGO_KEYFILE_PATH to ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\necho $MONGO_USER\n\n/usr/bin/cp -f $MONGO_KEYFILE_PATH ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\nerrorCheck \"Snapshot error: Unable to save keyfile $MONGO_KEYFILE_PATH to ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\nexit 0\n", 
        "status.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# status.sh\n# check status of the staging server for MONGO_STATUS_TYPE=\"staged\"\n# or vdb for MONGO_STATUS_TYPE=\"virtual\"\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='status.sh'\n\nlog \"Executing $PGM_NAME\"\n\ninitializeJQ\n\n# Get hostname - need this to lookup the member status\nhostname=$(hostname)\n\nlog \"Checking for instance --> $hostname:$MONGO_PORT\"\n\n# If Mongo process is not found we need to return the \"off\" code\ncurrent_instance=$(ps -ef | grep [m]ongod | grep \"\\--port $MONGO_PORT\" | grep \"\\--dbpath ${DLPX_DATA_DIRECTORY}\" | wc -l)\nif [[ $current_instance -eq 0 ]]; then\n        log \"Unable to find Mongo instance on port $MONGO_PORT with dbpath ${DLPX_DATA_DIRECTORY}\"\n        printf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n        exit 0\nfi\necho $MONGO_STATUS_TYPE\n#if it is a VDB then exit with success\nif [[ \"$MONGO_STATUS_TYPE\" = \"virtual\" ]]; then\n        log \"life is virtually good on port $MONGO_PORT\"\n        printf \"\\\"ACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n        exit 0\nfi\n\n# For staging servers we will check the replicaset status\njson=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port \"$MONGO_PORT\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n\n\n# We are intentionally supressing errors at .[] so that JQ does not throw an additional error when rs.status fails\nmongo_state=$(echo \"$json\" | jq \".members | .[]? | select(.self == true) | .state\")\nerrorCheck \"Unable to check Mongo status ($mongo_state)\\n$json\"\nif [[ $mongo_state -ne 2 ]]; then\n        errorLog \"Mongo in invalid state\\n$json\"\n        printf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n        exit 2\nfi\n\nlog \"life is good at $hostname:$MONGO_PORT\"\nprintf \"\\\"ACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\nexit 0", 
        "initiate.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# initiate.sh\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME=\"initiate.sh\"\n\ngetSystemInfo\n\nif [[ -z $MONGO_REPLICASET ]]; then\n        getConfigValue \"MONGO_REPLICASET\" \"MONGO_REPLICASET\"\nfi\n\noutput=$(mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.initiate())\")\n\nlog \"rs.initiate output: $output\"\n\nconfig=\"{_id: '$MONGO_REPLICASET', members:[{_id: 0, host: 'localhost:$MONGO_PORT'}]}\"\n\nlog \"Updating replicaset config with $config\"\n\noutput=$(mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.reconfig(${config}, {force: true}))\")\n\nlog \"mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.reconfig(${config}, {force: true}))\\\"\"\n\nlog \"rs.reconfig output: $output\"\n\nexit 0", 
        "startStaging.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# startStaging.sh\nset -x\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME=\"startStaging\"\n\nlog \"Running startStaging.sh\"\n\nPGM_NAME='startStaging.sh'\n\n# Check for dsource directory and make if not there\nhostname=$(hostname)\nkeyFileName=$(basename $MONGO_KEYFILE_PATH)\nif [[ -e ${DLPX_DATA_DIRECTORY}/${keyFileName} ]]; then\ndie \"Mongo instance already running at: $hostname: $MONGO_PORT\"\nfi\nif [[ -d $DLPX_DATA_DIRECTORY ]]; then\n\tlog \"Directory $DLPX_DATA_DIRECTORY already exist\"\nelse\n\tmkdir $DLPX_DATA_DIRECTORY\n\terrorCheck \"Error making directory $DLPX_DATA_DIRECTORY\"\nfi\t\n\nmongoCommand=\"mongod --logpath ${DLPX_DATA_DIRECTORY}/mongod.log --fork --dbpath $DLPX_DATA_DIRECTORY --journal --journalCommitInterval $MONGO_JOURNAL_FLUSH --replSet $MONGO_REPLICASET --oplogSize $MONGO_OPLOG_SIZE --port $MONGO_PORT\"\n\n# If storage engine is anything but mmap we need to add it explicitly. This is because --storageEngine is not a valid param for 2.6\nif [[ \"$MONGO_STORAGE_ENGINE\" != \"mmapv1\" ]]; then\n        mongoCommand=\"$mongoCommand --storageEngine $MONGO_STORAGE_ENGINE\"\nfi\n\n# Add keyfile only if path is specified\nif [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        mongoCommand=\"$mongoCommand --keyFile $MONGO_KEYFILE_PATH\"\nfi\n\nlog \"Starting Standby Instance:\\n$mongoCommand\"\noutput=$($mongoCommand)\nlog \"$output\"\n\ninitializeJQ\n\ncompleted_code=1\nwhile [[ $completed_code -ne 0 ]]\ndo\n        sleep 10\n        checkReplicationStatus\n        completed_code=$?\ndone\n\nlog \"\"\nexit 0", 
        "dropStagingFromPrimary.sh": "#\n# Copyright (c) 2014, 2016 by Delphix. All rights reserved.\n#\n# dropStagingFromPrimary.sh\n\nset -xv\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME=\"dropStagingFromPrimary\"\n\n\nlog \"Starting $PGM_NAME\"\n\ninitializeJQ\n\nlog \"Removing Delphix staging host $MONGO_STANDBY_HOST:$MONGO_PORT from replica set\"\n\n# Grab the primary replication port and host\nprimaryReplica=$(getPrimaryReplica \"$MONGO_REPLICASET\")\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\nlog \"mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \\\"rs.remove('$MONGO_STANDBY_HOST:${MONGO_PORT}'))\\\"\"\noutput=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.remove('$MONGO_STANDBY_HOST:${MONGO_PORT}'))\")\nlog \"Output: $output\"\nsuccess=$(echo \"$output\" | jq '.ok')\nif [ $success -eq 0 ]\nthen\n        code=$(echo \"$output\" | jq '.code')\n        errmsg=$(echo \"$output\" | jq '.errmsg')\n        die \"rs.add failed: Code: $code error:  $errmsg\"\nelse\n        log \"rs.remove succeeded\"\nfi\n\noutput=$(mongo -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$MONGO_STANDBY_HOST\" --port \"$MONGO_PORT\" --authenticationDatabase admin --quiet --eval \"printjson(rs.status())\")\nlog \"Output: $output\"\nexit 0", 
        "checkOwnership.sh": "#\n# Copyright (c) 2017 by Delphix. All rights reserved.\n#\n\n# We keep track of whether a VDB is running or not using a sentinel files.\n# Each running VDB has its own sentinel file, named using the VDB's GUID.\n# All of the sentinel files for a particular host are kept in a single directory,\n# inside the Delphix Engine's \"toolkit directory\".\nset -x\n\neval \"$MONGO_LIBRARY_SOURCE\"\n\nPGM_NAME='CheckOwnership.sh'\n\nlog \"Starting $PGM_NAME\"\n\nVDBDir=${DLPX_DATA_DIRECTORY}\n\ndeleteDBPath=$(ps -ef | grep \"\\-\\-port $MONGO_PORT\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--dbpath\") {print $(i+1)}}')\n\nif [[ \"$VDBDir\" == \"$deleteDBPath\" ]]; then\n\techo \"true\" > \"$DLPX_OUTPUT_FILE\"\nelse\n\techo \"false\" > \"$DLPX_OUTPUT_FILE\"\nfi\n\nexit 0"
    }
}